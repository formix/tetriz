#include "layout.z80"
#include "retroz-bios-inc.z80"

; https://tetris.wiki/

 MACRO CLOCK_TICK
    LD      HL,GAME_CLOCK
    INC     (HL)
 ENDM

 MACRO CPRINT &chr
    PUSH    AF
    LD      A,&chr
    CALL    OUTA
    POP     AF
 ENDM

 MACRO MUL_BY_8
    RLA
    RLA
    RLA
    AND     0b11111000
 ENDM

TETROMINO_COUNT     EQU      7
START_COL           EQU     30
START_ROW           EQU      2

#code _DATA

WELCOME     DEFB "=TetriZ=",0
PRESS_START DEFB "Press any key to start...",0
LABEL_LEVEL DEFB "=Level=",0
LABEL_SCORE DEFB "=Score=",0
LABEL_NEXT  DEFB "=Next=",0

TETROMINOS: DEFW $0E40,$4C40,$4E00,$4640    ; Tetromino 0, orientation 0 to 3
            DEFW $0E20,$44C0,$8E00,$6440    ; Tetromino 1, orientation 0 to 3
            DEFW $0C60,$2640,$0C60,$2640    ; Tetromino 2, orientation 0 to 3
            DEFW $0CC0,$0CC0,$0CC0,$0CC0    ; Tetromino 3, orientation 0 to 3
            DEFW $06C0,$4620,$06C0,$4620    ; Tetromino 4, orientation 0 to 3
            DEFW $0E80,$C440,$2E00,$4460    ; Tetromino 5, orientation 0 to 3
            DEFW $0F00,$4444,$0F00,$4444    ; Tetromino 6, orientation 0 to 3


#data _HEAP

GAME_CLOCK              DEFS 2
LAST_SPRITE             DEFS 1
NEXT_SPRITE             DEFS 1

STRUCT_TETROMINO        DEFS 4
ST_SPRITE               EQU  0      ; The sprite index (0-6)
ST_ORIENT               EQU  1      ; The sprite orientation (0-3)
ST_POS                  EQU  2      ; The position of the sprite
ST_COL                  EQU  2      ; The column position of the sprite
ST_ROW                  EQU  3      ; The row position of the sprite

PG_HEIGHT               EQU 20
PG_WIDTH                EQU 10
PLAYGROUND:             DEFS PG_HEIGHT * PG_WIDTH



#code _PROGRAM

MAIN:
    _ADDLP  WELCOME
    _CALL   PRINT
    CALL    PRINT_ENDL
    CALL    PRINT_ENDL

    _ADDLP  PRESS_START
    _CALL   PRINT
    CALL    PRINT_ENDL

    CALL    START_RX_INT    ;Start listening to keyboard inputs

    LD      HL,LAST_SPRITE         
    LD      (HL),-1

WAIT_START:
    CLOCK_TICK           ; Increments the seed by 1
    CALL    GETCHAR
    _jrlf   WAIT_START

    CALL    CLS
    CALL    DRAW_BOARD
    CALL    PICK_NEW_SHAPE


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                              GAME LOOP                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1 second ~ 61440 game loop                                              ;;
;; NES Frame rate is 60 per seconds.                                       ;;
;; 61440 / 60 = 1024, WOW!                                                 ;;
;; 1024 loops gives pretty exactly 1 NES frame, beatiful numbers!!!        ;;
;; To convert to a NES frame, just take the GAME_CLOCK high byte           ;;
;; shifted right twice.                                                    ;;
;; See the following frame time chart for level speeds:                    ;;
;;    https://harddrop.com/wiki/Tetris_(NES,_Nintendo)                     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GAME_LOOP:
    CLOCK_TICK           ; Increments the timer by 1
    CALL    GETCHAR
    _jrlf   GAME_LOOP

    CP      'w'
    LD      B,1
    CALL    Z,ROTATE

    CP      's'
    LD      B,-1
    CALL    Z,ROTATE

    CP      'a'
    LD      B,-1
    CALL    Z,TRANSLATE

    CP      'd'
    LD      B,1
    CALL    Z,TRANSLATE

    CP      'n'
    CALL    Z,MOVE_DOWN

    CP      ' '
    CALL    Z,EREASE_AND_PICK_NEW_SHAPE

    CP      'R'
    PUSH    AF
    CALL    Z,CLS
    POP     AF
    JP      Z,$8100

    CP      'Q'
    JP      Z,0

    JP      GAME_LOOP




DRAW_BOARD:
    ; main board
    _ADDLP  $0215
    _ADDLP  $1616
    _CALL   DRAW_RECT
    _ADDLP  $021C
    _CALL   SET_POS
    _ADDLP  WELCOME
    _CALL   PRINT

    ; level
    _ADDLP  $022C
    _ADDLP  $030D
    _CALL   DRAW_RECT
    _ADDLP  $022F
    _CALL   SET_POS
    _ADDLP  LABEL_LEVEL
    _CALL   PRINT

    ; score
    _ADDLP  $062C
    _ADDLP  $030D
    _CALL   DRAW_RECT
    _ADDLP  $062F
    _CALL   SET_POS
    _ADDLP  LABEL_SCORE
    _CALL   PRINT

    ; next
    _ADDLP  $0A2C
    _ADDLP  $060D
    _CALL   DRAW_RECT
    _ADDLP  $0A2F
    _CALL   SET_POS
    _ADDLP  LABEL_NEXT
    _CALL   PRINT

    RET


; The clock increments every ~120 crystal Ticks
; ROTATE and TRANSLATE take each around 15500 crystal ticks to execute.
; Means that each time a rotation or a translation is made, we shall
; fast forward the clock by 15500 / 120. That accouts to around 130 game 
; clock tick. We use 131 just for the sake of using a prime number.
FAST_FORWARD_CLOCK:
    LD      HL,(GAME_CLOCK)
    LD      DE,131
    ADD     HL,DE
    LD      (GAME_CLOCK),HL
    RET


MOVE_DOWN:
    PUSH        AF
    
    ; Erease the tetromino at its current orientation
    _ADDLP  ACTION_EREASE   ; Erease = TRUE
    _ADDLP  STRUCT_TETROMINO
    _CALL   DRAW_TETROMINO

    ; Increment the row
    LD      IX,STRUCT_TETROMINO
    INC     (IX+ST_ROW)

    ; Draw the tetromino at its new position
    _ADDLP  ACTION_DRAW
    _ADDLP  STRUCT_TETROMINO
    _CALL   DRAW_TETROMINO

    POP     AF
    RET


TRANSLATE:
    PUSH        AF
    ; Erease the tetromino at its current orientation
    _ADDLP  ACTION_EREASE   ; Erease = TRUE
    _ADDLP  STRUCT_TETROMINO
    _CALL   DRAW_TETROMINO
    LD      IX,STRUCT_TETROMINO
    LD      A,B
    ADD     B
    ADD     (IX+ST_COL)
    LD      (IX+ST_COL),A
    _ADDLP  ACTION_DRAW   ; Erease = FALSE
    _ADDLP  STRUCT_TETROMINO
    _CALL   DRAW_TETROMINO
    POP     AF
    JP      FAST_FORWARD_CLOCK ;Will return in that subroutine


EREASE_AND_PICK_NEW_SHAPE:

    ; Erease the tetromino at its current orientation
    _ADDLP      ACTION_EREASE   ; Erease = TRUE
    _ADDLP      STRUCT_TETROMINO
    _CALL       DRAW_TETROMINO

PICK_NEW_SHAPE:

    ; Get a random tetromino index
    LD      HL,(GAME_CLOCK)
    _ADDRP  HL          ; Add the random seed value as MODULO parameter 1 (divisee).
    LD      L,TETROMINO_COUNT
    _ADDRP  HL          ; Add the divisor as MODULO parameter 0 (divisor).
    _CALL   MODULO      ; Get the tetromino index in L
    LD      A,L         ; The random tetromino index is in A

    LD      HL,LAST_SPRITE         
    CP      (HL)        ; Check if the new sprite is the same as the last one
    JR      NZ,PICK_NEW_SHAPE_SET_SPRITE; Different, set that sprite
    INC     A           ; The same, move to the next sprite
    CP      7           ; check if we rolled over
    JR      NZ,PICK_NEW_SHAPE_SET_SPRITE; not rolled over, pick that sprite
    LD      A,0         ; roll over

PICK_NEW_SHAPE_SET_SPRITE:
    LD      (LAST_SPRITE),A ; Save the selected sprite
    ; Initialize the tetromino structure
    LD      IX,STRUCT_TETROMINO
    LD      (IX+ST_SPRITE),A
    LD      (IX+ST_ORIENT     ),0
    LD      (IX+ST_COL),START_COL
    LD      (IX+ST_ROW),START_ROW

    _ADDLP  ACTION_DRAW           ; Draw tetromino
    _ADDRP  IX
    _CALL   DRAW_TETROMINO

    RET


;;;;;;;;;;;;;;;;;;; ROTATE ;;;;;;;;;;;;;;;;;;;
;; Inputs: B the rotation value. 1 = clockwise, -1 = counter-clockwise
ROTATE:
    PUSH    AF
    ; Erease the tetromino at its current orientation
    _ADDLP  ACTION_EREASE   ; Erease = TRUE
    _ADDLP  STRUCT_TETROMINO
    _CALL   DRAW_TETROMINO
    ; Load the tetromino into the indexer register
    LD      IX,STRUCT_TETROMINO
    LD      A,(IX+ST_ORIENT     )
    ; Do the rotation
    ADD     B
    AND     $03         ; Modulo 4
    LD      (IX+ST_ORIENT     ),A
    ; Draw the tetromino with its new orientation.
    _ADDLP  ACTION_DRAW
    _ADDRP  IX
    _CALL   DRAW_TETROMINO
    POP     AF
    JP      FAST_FORWARD_CLOCK ;Will return in that subroutine
    



;;;;;;;;;;;;;;;;;;; DRAW_TETROMINO ;;;;;;;;;;;;;;;;;;;
; Flags for the erease parameter
ACTION_EREASE       EQU 1
ACTION_DRAW         EQU 0
; DRAW_TETROMINO's parameters
DT_PARAM_ACTION     EQU 1   ; If LByte == 0: draw; if LByte == 1: erease
DT_PARAM_TETROMINO  EQU 0   ; Expect the address of a tetromino structure
; Constant values required by the DRAW_TETROMINOS function
DT_NEXT_LINE    DEFB ESC,"[B",ESC,"[8D",0 ;Down 1, back 8
DT_FORWARD_2    DEFB ESC,"[2C",0
DT_BLOCK        DEFB "##",0

; Draw a tetromino at a screen position with a given color.
DRAW_TETROMINO:

    _GETP       BC,DT_PARAM_TETROMINO
    LD          IXh,B
    LD          IXl,C   ; IX contains the tetromino structure

    ; Set cursor position
    LD          BC,(IX+ST_POS)
    _ADDRP      BC                  ; Add the position parameter for SET_COLOR call
    _CALL       SET_POS             ; Call the set position function

    ; Set the tetromino color
    _GETP       DE,DT_PARAM_ACTION
    LD          L,E                 ;
    _jrlf       DRAW_TETROMINO_DRAW ; Jump if L is ACTION_DRAW (which correspond to FALSE)
    LD          B,'0'               ; Set the color to the background color to erease
    LD          C,B
    JR          DRAW_TETROMINO_SET_COLOR

DRAW_TETROMINO_DRAW:
    LD          A,(IX+ST_SPRITE)
    ADD         '1'                 ; Convert the sprite index to an ANSI color code
    LD          B,A                 ; Set the background...
    LD          C,A                 ; ...and the foreground to the same color.

DRAW_TETROMINO_SET_COLOR:
    _ADDRP      BC                  ; Add background (B) and foreground (C) as parameters
    _CALL       SET_COLOR           ; Call the set color function

    ; Load the sprite value into DE using the sprite address
    LD          A,(IX+ST_SPRITE)
    MUL_BY_8                        ; Convert the sprite index to a byte position, each sprite size being 8 bytes
    ADD         A,(IX+ST_ORIENT     )
    ADD         A,(IX+ST_ORIENT     ) ; Sets the correct orientation (2 x orientation)
    LD          HL,$0000
    LD          L,A                 ; H=0, L=A
    LD          DE,TETROMINOS
    ADD         HL,DE               ; HL contains the sprite address
    LD          E,(HL)
    INC         HL
    LD          D,(HL)              ; DE contains the sprite value

    ; Create a 4 bytes array to store each sprite row on the stack
    PUSH        HL
    PUSH        HL

    ; Initialize the array of rows. Row data is stored in the high nibble of each byte.
    LD          IY,$0000
    ADD         IY,SP               ; Initialize the indexer to the array address
    LD          (IY+0),D            ; First row
    SLA         D
    SLA         D
    SLA         D
    SLA         D                   ; Shift left 4 bits
    LD          (IY+1),D            ; second row
    LD          (IY+2),E            ; third row
    SLA         E
    SLA         E
    SLA         E
    SLA         E                   ; shift left 4 bits
    LD          (IY+3),E            ; fourth row
    
    ; Initialize the array cursor HL to the first array element.
    PUSH        IY                  ; Save the rows address on the stack
    POP         HL                  ; Get the rowsaddress back into HL

    ; Draw the tetromino
    LD          B,4                 ; Initialize the row counter
DT_DRAW_ROWS:
    LD          C,4                 ; Initialize the col counter
    LD          A,(HL)              ; Load the row into A
    AND         $F0                 ; Mask the row data
    ; JR          NZ,DT_DRAW_COLS     ; If A != 0, draw that row
    ; DEC         B                   ; Row is empty, skip that row
    ; JR          Z,DT_END            ; No more rows, we are done
    ; INC         HL                  ; Move the cursor to the next row byte
    ; JR          DT_DRAW_ROWS        ; Draw the next row
DT_DRAW_COLS:
    SLA         A
    JR          C,DT_PRINT          ; Check if the bit is set
    _ADDLP      DT_FORWARD_2        ; Not set, skip two characters
    _CALL       PRINT
    JR          DT_DRAW_COLS_END
DT_PRINT:
    _ADDLP      DT_BLOCK            ; Bit is set, print a block
    _CALL       PRINT
DT_DRAW_COLS_END:
    DEC         C                   ; One less column to print
    JR          NZ,DT_DRAW_COLS     ; Jump to draw the next column if it is not the last column
    DEC         B                   ; Done dwaing the row, decrement the row count
    JR          Z,DT_END            ; Jump to the end of the function if that was the last row
    INC         HL                  ; Increment the array cursor
    _ADDLP      DT_NEXT_LINE
    _CALL       PRINT               ; Set the cursor on the next line to draw
    JR          DT_DRAW_ROWS        ; Jump to draw the next row

DT_END:
    ; Delete the array from the stack
    POP         HL
    POP         HL

    ; "Hide" the cursor in the top left corner
    _ADDLP      $0101
    _CALL       SET_POS

    RET



; Computes the remainder of the division.
MOD_PARAM_DIVISEE     EQU     1
MOD_PARAM_DIVISOR     EQU     0     ; 8 bits, second register (8L)
; Returns the modulo result in L
; H content is unknown
; taken from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Division#8.2F8_division
MODULO:
    _GETP   HL,MOD_PARAM_DIVISEE
    _GETP   BC,MOD_PARAM_DIVISOR

; The following routine divides hl by c and places the quotient in hl and the remainder in a 
    xor	a
    ld	b, 16
_div_hl_c_loop:
    add	hl, hl
    rla
    jr	c, $+5
    cp	c
    jr	c, $+4
    sub	c
    inc	l
    djnz _div_hl_c_loop
    LD      L,A
    _RET_HL HL

