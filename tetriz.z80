#target bin

#include "retroz-bios-inc.z80"
#include "callstack.z80"


    MACRO _ADD_DEBC
    EX      DE,HL
    ADD     HL,BC
    EX      DE,HL
    ENDM

;layout
#code   _HEADER
#code   _PROGRAM
#code   _PROGRAM_FOOTER
#code   _DATA
#data   _HEAP,_DATA_end

EXEC_TARGET     EQU $8100
PG_ROWS         EQU 21
PG_COLS         EQU 12

#data _HEAP
    .PHASE  EXEC_TARGET+_PROGRAM_size+_DATA_size

ITOA_BUF        DEFS 17
PLAYGROUND      DEFS PG_ROWS * PG_COLS
RND_SEED        DEFS 1
SPRITE_INDEX    DEFS 1
SPRITE_ORIENT   DEFS 1
SPRITE_ROW      DEFS 1
SPRITE_COL      DEFS 1
SCREEN_DIRTY    DEFS 1


#code _HEADER
    DEFB 0
    DEFW _PROGRAM_size+_DATA_size
    DEFW EXEC_TARGET


#code _DATA
    .PHASE  EXEC_TARGET+_PROGRAM_size

WELCOME         DEFB "+++ TetriZ +++",0
PRESS_ANY_KEY   DEFB "Press any key to reset...",0
RESETTING       DEFB "Resetting...",0
PADDING         DEFB "+++++",0

#include "tetroids.z80"


#code _PROGRAM
    .PHASE  EXEC_TARGET

    ; Initialization

    _ADDLP  WELCOME
    _CALL   PRINTLN
    CALL    NEWLINE

    _ADDLP  1500
    _CALL   SLEEP
    CALL    CLS
    CALL    INIT_PLAYGROUND

    _ADDLP  PADDING
    _CALL   PRINT
    _ADDLP  WELCOME
    _CALL   PRINT
    _ADDLP  PADDING
    _CALL   PRINTLN
    CALL    PRINT_PLAYGROUND

    CALL    SPAWN_SPRITE
    CALL    DRAW_SPRITE


    _ADDLP  PRESS_ANY_KEY
    _CALL   PRINTLN


    CALL    START_RX_INT    ;Start listening to keyboard inputs


PROGRAM_LOOP:
    LD      HL,RND_SEED
    INC     (HL)

    LD      A,1
    LD      HL,SCREEN_DIRTY
    CP      (HL)
    CALL    Z,PRINT_PLAYGROUND

    CALL    GETCHAR         ; Read the next character in the console
    JR      Z, PROGRAM_LOOP ; Loop if no key pressed.
    _ADDLP  RESETTING
    _CALL   PRINTLN
    JP      0               ;Hot reset



PRINTLN:
    POP     IX
    CALL    PRINT
    LD      A,10
    CALL    OUTC
    LD      A,13
    CALL    OUTC
    PUSH    IX
    RET

NEWLINE:
    LD      A,10
    CALL    OUTC
    LD      A,13
    CALL    OUTC
    RET


UINT_TO_STRING:
    _GETP   DE,0
    _ADDLP  10              ;Decimal display (conv. base)
    _ADDRP  DE              ;The number to convert
    _ADDLP  17              ;The size of the string buffer
    _ADDLP  ITOA_BUF        ;The target string buffer
    _CALL   ITOA
    _RET_HL HL



INIT_PLAYGROUND:
    LD      C,0
    LD      HL,PLAYGROUND
INIT_PLAYGROUND_LINE:
    LD      A,'+' - ' '
    LD      (HL),A
    INC     HL
    LD      B,10
    LD      A,0
INIT_PLAYGROUND_CELL:
    LD      (HL),A
    INC     HL
    DEC     B
    JR      NZ,INIT_PLAYGROUND_CELL
    LD      A,'+' - ' '
    LD      (HL),A
    INC     HL
    INC     C
    LD      A,20
    CP      C
    JR      NZ,INIT_PLAYGROUND_LINE
    LD      B,12
INIT_PLAYGROUND_BOTTOM:
    LD      A,'+' - ' '
    LD      (HL),A
    INC     HL
    DEC     B
    JR      NZ,INIT_PLAYGROUND_BOTTOM
    RET


PRINT_PLAYGROUND:
    LD      B,2
    LD      C,0
    _ADDRP  BC
    _CALL   SET_POS
    LD      HL,PLAYGROUND
    LD      B,12
    LD      C,0
PRINT_PLAYGROUND_CHAR
    LD      A,(HL)
    ADD     ' '
    CALL    OUTC
    CALL    OUTC
    INC     HL
    DEC     B
    JR      NZ,PRINT_PLAYGROUND_CHAR
    CALL    NEWLINE
    INC     C
    LD      A,21
    CP      C
    JR      Z,PRINT_PLAYGROUND_END
    LD      B,12
    JR      PRINT_PLAYGROUND_CHAR
PRINT_PLAYGROUND_END:
    XOR     A                           ; Reset A to 0
    LD      (SCREEN_DIRTY),A            ; Not dirty
    RET


SPAWN_SPRITE:
    LD      A,3 ; shall select randomly here
    LD      (SPRITE_INDEX),A
    LD      A,0
    LD      (SPRITE_ORIENT),A
    LD      A,1
    LD      (SPRITE_ROW),A
    LD      A,4
    LD      (SPRITE_COL),A
    RET


DRAW_SPRITE:
    _CALL   GET_SPRITE
    PUSH    HL                  ; Save the sprite address on the stack
    _CALL   GET_PLAYGROUND_POS  ; Get the drawing start address
    EX      DE,HL               ; Put the drawing address in DE
    POP     HL                  ; Get back the sprite address in HL
    LD      B,4                 ; Number of rows of the sprite
DRAW_SPRITE_ROW:
    LD      C,4                 ; Number of columns of the sprite
DRAW_SPRITE_CHAR:
    LD      A,(HL)              ; Load the first sprite byte
    SUB     ' '                 ; Check if it is empty
    JR      Z,DRAW_SPRITE_NEXTCHAR  ; Do not print anything if empty
    LD      (DE),A              ; Set the playground "pixel"
DRAW_SPRITE_NEXTCHAR:
    INC     HL
    INC     DE
    DEC     C
    JR      NZ,DRAW_SPRITE_CHAR ; Print the next char if not zero
    DEC     B
    JR      Z,DRAW_SPRITE_END   ; If last row was printed, exit
    PUSH    BC                  ; Save counters
    LD      BC,PG_COLS - 4      ; Get the number of byte to skip
    _ADD_DEBC                   ; Skip to the next line
    POP     BC                  ; Get counters back in BC
    JR      DRAW_SPRITE_ROW     ; Print the next row
DRAW_SPRITE_END:
    LD      A,1
    LD      (SCREEN_DIRTY),A    ; Set the screen dirty byte
    RET


GET_SPRITE:
    LD      B,16*4              ; Memeory size of a tetroid
    LD      A,(SPRITE_INDEX)    ; Current tetroid
    LD      C,A
    _ADDRP  BC                  ; Add the two 8 bit reg as parameters
    _CALL   MUL8                ; Multiply to get the tetroid index
    PUSH    HL                  ; Save tetroid index on the stack
    LD      B,16                ; Memory size of a tetroid sprite
    LD      A,(SPRITE_ORIENT)   ; Load the tetroid orientation
    LD      C,A
    _ADDRP  BC                  ; Param: tetroid size and orientation
    _CALL   MUL8                ; Multiply together to get the shift
    POP     BC                  ; Get the tetroid index back in BC
    ADD     HL,BC               ; Add orient. to tetroid index = sprite index
    LD      BC,TETROIDS         ; Load the TETROIDS address in BC
    ADD     HL,BC               ; Add the tetroid address to the sprite index
    _RET_HL HL                  ; Return the tetroid sprite address


GET_PLAYGROUND_POS:
    LD      A,(SPRITE_ROW)       ; Load the sprite row
    LD      B,A
    LD      C,PG_COLS           ; Load the number of columns in a row
    _ADDRP  BC                  ; Add the two 8 bit params
    _CALL   MUL8                ; Multiply them together
    XOR     A                   ; Set A to 0
    LD      B,A                 ; Reset B
    LD      A,(SPRITE_COL)       ; Load the SPRITE col
    LD      C,A
    ADD     HL,BC               ; Add the column to the row index
    LD      BC,PLAYGROUND       ; Load the playground address
    ADD     HL,BC               ; Add the address to the index
    _RET_HL HL                  ; return the sprite positin in playground

; ***************************************************************************
; Multiply the two byte parameters and return the result in a word.
;       Inputs: Param 0: the two byte values to multiply.
;       Returns: The multiplication result in HL.
;
; I started implementing this myself and ended up copying that code 
; (and comments) from a website I forgot. Quite similar to what I did, 
; except for the stack parameters extraction. If you are the author of these
; lines please email me and I'll give you credit here.
; ***************************************************************************
MUL8:
    _GETP   DE,0
    LD      A,D
    LD      HL,0            ; set accumulator to 0
    LD      D,H             ; (makes adding 'E' to 'accumulator' easier)
MUL8_LOOP:      
    OR      A               ; while a is not 0, then:
    JR      Z,MUL8_END      ; we are done.
    RRA                     ; shift A right, carrying out the bottom bit
    JR      NC,MUL8_SKIP    ; if 1 is carried out:
    ADD     HL,DE           ; add E to the accumulator
MUL8_SKIP:
    SLA     E               ; shift E to the left, shifting in 0.
    RL      D               
    JR      MUL8_LOOP
MUL8_END:
    _RET_HL HL


END