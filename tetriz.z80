#target bin

#include "retroz-bios-inc.z80"
#include "callstack.z80"


    MACRO   _EX &reg1, &reg2
    PUSH    &reg1
    PUSH    &reg2
    POP     &reg1
    POP     &reg2
    ENDM


;layout
#code   _HEADER
#code   _PROGRAM
#code   _PROGRAM_FOOTER
#code   _DATA
#data   _HEAP,_DATA_end

EXEC_TARGET     EQU $8100
PG_ROWS         EQU 21
PG_COLS         EQU 12

#data _HEAP
    .PHASE  EXEC_TARGET+_PROGRAM_size+_DATA_size

ITOA_BUF        DEFS 17
PLAYGROUND      DEFS PG_ROWS * PG_COLS
RND_SEED        DEFS 1
SHAPE_INDEX     DEFS 1
SHAPE_ORIENT    DEFS 1
SHAPE_ROW       DEFS 1
SHAPE_COL       DEFS 1
SCREEN_DIRTY    DEFS 1


#code _HEADER
    DEFB 0
    DEFW _PROGRAM_size+_DATA_size
    DEFW EXEC_TARGET


#code _DATA
    .PHASE  EXEC_TARGET+_PROGRAM_size

WELCOME         DEFB "+++ TetriZ +++",0
PRESS_ANY_KEY   DEFB "Press any key to reset...",0
RESETTING       DEFB "Resetting...",0
PADDING         DEFB "+++++",0

#include "shapes.z80"


#code _PROGRAM
    .PHASE  EXEC_TARGET

    ; Initialization

    _ADDLP  WELCOME
    _CALL   PRINTLN
    CALL    NEWLINE

    _ADDLP  1500
    _CALL   SLEEP
    CALL    CLS

    CALL    INIT_PLAYGROUND
    CALL    INIT_SHAPES

    _ADDLP  PADDING
    _CALL   PRINT
    _ADDLP  WELCOME
    _CALL   PRINT
    _ADDLP  PADDING
    _CALL   PRINTLN
    CALL    PRINT_PLAYGROUND

    CALL    SPAWN_SHAPE
    ;CALL    DRAW_SHAPE


    _ADDLP  PRESS_ANY_KEY
    _CALL   PRINTLN


    CALL    START_RX_INT    ;Start listening to keyboard inputs


PROGRAM_LOOP:
    LD      HL,RND_SEED
    INC     (HL)

    LD      A,1
    LD      HL,SCREEN_DIRTY
    CP      (HL)
    CALL    Z,PRINT_PLAYGROUND

    CALL    GETCHAR         ; Read the next character in the console
    JR      Z, PROGRAM_LOOP ; Loop if no key pressed.
    _ADDLP  RESETTING
    _CALL   PRINTLN
    JP      0               ;Hot reset



PRINTLN:
    POP     IX
    CALL    PRINT
    LD      A,10
    CALL    OUTC
    LD      A,13
    CALL    OUTC
    PUSH    IX
    RET

NEWLINE:
    LD      A,10
    CALL    OUTC
    LD      A,13
    CALL    OUTC
    RET


UINT_TO_STRING:
    _GETP   DE,0
    _ADDLP  10              ;Decimal display (conv. base)
    _ADDRP  DE              ;The number to convert
    _ADDLP  17              ;The size of the string buffer
    _ADDLP  ITOA_BUF        ;The target string buffer
    _CALL   ITOA
    _RET_HL HL



INIT_PLAYGROUND:
    LD      C,0
    LD      HL,PLAYGROUND
INIT_PLAYGROUND_LINE:
    LD      A,'+'
    LD      (HL),A
    INC     HL
    LD      B,10
    LD      A,' '
INIT_PLAYGROUND_CELL:
    LD      (HL),A
    INC     HL
    DEC     B
    JR      NZ,INIT_PLAYGROUND_CELL
    LD      A,'+'
    LD      (HL),A
    INC     HL
    INC     C
    LD      A,20
    CP      C
    JR      NZ,INIT_PLAYGROUND_LINE
    LD      B,12
INIT_PLAYGROUND_BOTTOM:
    LD      A,'+'
    LD      (HL),A
    INC     HL
    DEC     B
    JR      NZ,INIT_PLAYGROUND_BOTTOM
    RET


PRINT_PLAYGROUND:
    LD      HL,PLAYGROUND
    LD      B,12
    LD      C,0
PRINT_PLAYGROUND_CHAR
    LD      A,(HL)
    CALL    OUTC
    CALL    OUTC
    INC     HL
    DEC     B
    JR      NZ,PRINT_PLAYGROUND_CHAR
    CALL    NEWLINE
    INC     C
    LD      A,21
    CP      C
    JR      Z,PRINT_PLAYGROUND_END
    LD      B,12
    JR      PRINT_PLAYGROUND_CHAR
PRINT_PLAYGROUND_END:
    XOR     A                           ; Reset A to 0
    LD      (SCREEN_DIRTY),A            ; Not dirty
    RET


; Repace spaces with \0
INIT_SHAPES:
    LD      C,0
    LD      HL,SHAPES
    LD      DE,SHAPES_END
INIT_SHAPES_COMPARE:    
    LD      A,' '
    CP      (HL)
    JR      Z,INIT_SHAPES_CLEAR
    JR      INIT_SHAPES_NEXT
INIT_SHAPES_CLEAR:
    LD      (HL),C
INIT_SHAPES_NEXT:
    INC     HL
    LD      A,D
    CP      H
    JR      NZ,INIT_SHAPES_COMPARE
    LD      A,E
    CP      L
    JR      NZ,INIT_SHAPES_COMPARE
    RET


SPAWN_SHAPE:
    LD      A,3 ; shall select randomly here
    LD      (SHAPE_INDEX),A
    LD      A,0
    LD      (SHAPE_ORIENT),A
    LD      A,0
    LD      (SHAPE_ROW),A
    LD      A,4
    LD      (SHAPE_COL),A
    RET


DRAW_SHAPE:
    ; find position in the shape table
    LD      H,16*4
    LD      A,(SHAPE_INDEX)
    LD      L,A
    _ADDRP  HL
    _CALL   MUL8                ; HL is now at the first orient of the shape
    LD      BC,16
    LD      E,0
    LD      A,(SHAPE_ORIENT)
DRAW_SHAPE_SEARCH_ORIENT:
    CP      E
    JR      Z,DRAW_SHAPE_ORIENT_FOUND
    ADD     HL,BC
    INC     E
    JR      DRAW_SHAPE_SEARCH_ORIENT
DRAW_SHAPE_ORIENT_FOUND:
    PUSH    HL                  ; Save the selected shape
    LD      HL,SHAPE_ROW
    LD      B,(HL)
    LD      C,PG_ROWS
    _ADDRP  BC
    _CALL   MUL8                ; HL targets the start of the row
    LD      DE,(SHAPE_COL)
    ADD     HL,DE               ; HL is at the right position in PLAYGROUND
    PUSH    HL
    POP     DE                  ; DE contains the position in PLAYGROUND
    POP     HL                  ; HL contains the selected shape
    LD      B,4                 ; Initialize the row counter
DRAW_SHAPE_ROW:
    LD      C,4                 ; Initialize the col counter
DRAW_SHAPE_CHAR:
    LD      A,(HL)
    LD      (DE),A
    INC     HL
    INC     DE
    DEC     C
    JR      NZ,DRAW_SHAPE_CHAR
    PUSH    HL
    PUSH    DE
    POP     HL
    LD      DE,PG_COLS
    ADD     HL,DE               ; Moved the playground pos to the next row
    PUSH    HL
    POP     DE
    POP     HL                  ; HL is back in the shape
    DEC     B
    JR      NZ,DRAW_SHAPE_ROW
    LD      A,1
    LD      (SCREEN_DIRTY),A
    RET


; ***************************************************************************
; Multiply the two byte parameters and return the result in a word.
;       Inputs: Param 0: the two byte values to multiply.
;       Returns: The multiplication result in HL.
;
; I started implementing this myself and ended up copying that code 
; (and comments) from a website I forgot. Quite similar to what I did, 
; except for the stack parameters extraction. If you are the author of these
; lines please email me and I'll give you credit here.
; ***************************************************************************
MUL8:
    _GETP   DE,0
    LD      A,D
    LD      HL,0            ; set accumulator to 0
    LD      D,H             ; (makes adding 'E' to 'accumulator' easier)
MUL8_LOOP:      
    OR      A               ; while a is not 0, then:
    JR      Z,MUL8_END      ; we are done.
    RRA                     ; shift A right, carrying out the bottom bit
    JR      NC,MUL8_SKIP    ; if 1 is carried out:
    ADD     HL,DE           ; add E to the accumulator
MUL8_SKIP:
    SLA     E               ; shift E to the left, shifting in 0.
    RL      D               
    JR      MUL8_LOOP
MUL8_END:
    _RET_HL HL


END